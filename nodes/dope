#!/usr/bin/env python

# Copyright (c) 2018 NVIDIA Corporation. All rights reserved.
# This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
# https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode

"""
This file starts a ROS node to run DOPE, 
listening to an image topic and publishing poses.
"""

from __future__ import print_function

import numpy as np
import rospkg
import rospy
import yaml
from PIL import Image
from PIL import ImageDraw
from cv_bridge import CvBridge
from dope.inference.cuboid import Cuboid3d
from dope.inference.cuboid_pnp_solver import CuboidPNPSolver
from dope.inference.detector import ModelData, ObjectDetector
from geometry_msgs.msg import PoseStamped
from sensor_msgs.msg import Image as ImageSensor_msg
from std_msgs.msg import String

### Global Variables
g_path2package = rospkg.RosPack().get_path('dope')
g_bridge = CvBridge()


class Draw(object):
    """Drawing helper class to visualize the neural network output"""

    def __init__(self, im):
        """
        :param im: The image to draw in.
        """
        self.draw = ImageDraw.Draw(im)

    def draw_line(self, point1, point2, line_color, line_width=2):
        """Draws line on image"""
        if point1 is not None and point2 is not None:
            self.draw.line([point1, point2], fill=line_color, width=line_width)

    def draw_dot(self, point, point_color, point_radius):
        """Draws dot (filled circle) on image"""
        if point is not None:
            xy = [
                point[0] - point_radius,
                point[1] - point_radius,
                point[0] + point_radius,
                point[1] + point_radius
            ]
            self.draw.ellipse(xy,
                              fill=point_color,
                              outline=point_color
                              )

    def draw_cube(self, points, color=(255, 0, 0)):
        """
        Draws cube with a thick solid line across
        the front top edge and an X on the top face.
        """

        # draw front
        self.draw_line(points[0], points[1], color)
        self.draw_line(points[1], points[2], color)
        self.draw_line(points[3], points[2], color)
        self.draw_line(points[3], points[0], color)

        # draw back
        self.draw_line(points[4], points[5], color)
        self.draw_line(points[6], points[5], color)
        self.draw_line(points[6], points[7], color)
        self.draw_line(points[4], points[7], color)

        # draw sides
        self.draw_line(points[0], points[4], color)
        self.draw_line(points[7], points[3], color)
        self.draw_line(points[5], points[1], color)
        self.draw_line(points[2], points[6], color)

        # draw dots
        self.draw_dot(points[0], point_color=color, point_radius=4)
        self.draw_dot(points[1], point_color=color, point_radius=4)

        # draw x on the top
        self.draw_line(points[0], points[5], color)
        self.draw_line(points[1], points[4], color)


class DopeNode(object):
    """ROS node that listens to image topic, runs DOPE, and publishes DOPE results"""
    def __init__(self, params):
        self.params = params
        self.pubs = {}
        self.models = {}
        self.pnp_solvers = {}
        self.pub_dimension = {}
        self.draw_colors = {}

        # Initialize parameters
        matrix_camera = np.zeros((3, 3))
        matrix_camera[0, 0] = params["camera_settings"]['fx']
        matrix_camera[1, 1] = params["camera_settings"]['fy']
        matrix_camera[0, 2] = params["camera_settings"]['cx']
        matrix_camera[1, 2] = params["camera_settings"]['cy']
        matrix_camera[2, 2] = 1
        dist_coeffs = np.zeros((4, 1))

        if "dist_coeffs" in params["camera_settings"]:
            dist_coeffs = np.array(params["camera_settings"]['dist_coeffs'])
        self.config_detect = lambda: None
        self.config_detect.mask_edges = 1
        self.config_detect.mask_faces = 1
        self.config_detect.vertex = 1
        self.config_detect.threshold = 0.5
        self.config_detect.softmax = 1000
        self.config_detect.thresh_angle = params['thresh_angle']
        self.config_detect.thresh_map = params['thresh_map']
        self.config_detect.sigma = params['sigma']
        self.config_detect.thresh_points = params["thresh_points"]

        # For each object to detect, load network model, create PNP solver, and start ROS publishers
        for model in params['weights']:
            self.models[model] = \
                ModelData(
                    model,
                    g_path2package + "/weights/" + params['weights'][model]
                )
            self.models[model].load_net_model()

            self.draw_colors[model] = \
                tuple(params["draw_colors"][model])
            self.pnp_solvers[model] = \
                CuboidPNPSolver(
                    model,
                    matrix_camera,
                    Cuboid3d(params['dimensions'][model]),
                    dist_coeffs=dist_coeffs
                )
            self.pubs[model] = \
                rospy.Publisher(
                    '{}/pose_{}'.format(params['topic_publishing'], model),
                    PoseStamped,
                    queue_size=10
                )
            self.pub_dimension[model] = \
                rospy.Publisher(
                    '{}/dimension_{}'.format(params['topic_publishing'], model),
                    String,
                    queue_size=10
                )

        # Start ROS publisher
        self.pub_rgb_dope_points = \
            rospy.Publisher(
                params['topic_publishing'] + "/rgb_points",
                ImageSensor_msg,
                queue_size=10
            )

        topic_cam = params['topic_camera']

        # Starts ROS listener
        rospy.Subscriber(
            topic_cam,
            ImageSensor_msg,
            self.image_callback,
            queue_size=1
        )

        print("Running DOPE...  (Listening to camera topic: '{}')".format(topic_cam))
        print("Ctrl-C to stop")

    def image_callback(self, msg):
        """Image callback"""
        img = g_bridge.imgmsg_to_cv2(msg, "rgb8")
        # cv2.imwrite('img.png', cv2.cvtColor(img, cv2.COLOR_BGR2RGB))  # for debugging

        # Copy and draw image
        img_copy = img.copy()
        im = Image.fromarray(img_copy)
        draw = Draw(im)

        for m in self.models:
            # Detect object
            results = ObjectDetector.detect_object_in_image(
                self.models[m].net,
                self.pnp_solvers[m],
                img,
                self.config_detect
            )

            # Publish pose and overlay cube on image
            for i_r, result in enumerate(results):
                if result["location"] is None:
                    continue
                loc = result["location"]
                ori = result["quaternion"]
                msg = PoseStamped()
                msg.header.frame_id = self.params["frame_id"]
                msg.header.stamp = rospy.Time.now()
                CONVERT_SCALE_CM_TO_METERS = 100
                msg.pose.position.x = loc[0] / CONVERT_SCALE_CM_TO_METERS
                msg.pose.position.y = loc[1] / CONVERT_SCALE_CM_TO_METERS
                msg.pose.position.z = loc[2] / CONVERT_SCALE_CM_TO_METERS
                msg.pose.orientation.x = ori[0]
                msg.pose.orientation.y = ori[1]
                msg.pose.orientation.z = ori[2]
                msg.pose.orientation.w = ori[3]

                # Publish
                self.pubs[m].publish(msg)
                self.pub_dimension[m].publish(str(self.params['dimensions'][m]))

                # Draw the cube
                if None not in result['projected_points']:
                    points2d = []
                    for pair in result['projected_points']:
                        points2d.append(tuple(pair))
                    draw.draw_cube(points2d, self.draw_colors[m])

        # Publish the image with results overlaid
        self.pub_rgb_dope_points.publish(
            CvBridge().cv2_to_imgmsg(
                np.array(im)[..., ::-1],
                "bgr8"
            )
        )


def main():
    """Main routine to run DOPE"""

    # Initialize ROS node
    rospy.init_node('dope')
    argv = rospy.myargv()

    if len(argv) > 1:
        config_name = argv[1]
    else:
        config_name = "config_pose.yaml"
    params = None
    yaml_path = g_path2package + '/config/{}'.format(config_name)
    with open(yaml_path, 'r') as stream:
        try:
            print("Loading DOPE parameters from '{}'...".format(yaml_path))
            params = yaml.load(stream)
            print('    Parameters loaded.')
        except yaml.YAMLError as exc:
            print(exc)

    n = DopeNode(params)

    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        pass


if __name__ == "__main__":
    main()
